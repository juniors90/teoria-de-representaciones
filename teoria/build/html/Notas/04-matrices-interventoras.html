

<!DOCTYPE html>
<html class="writer-html5" lang="es" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>6. Matrices Interventoras &mdash; documentación de Teoría de Representaciones de Grupos - 0.0.1</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/translations.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="next" title="7. Módulos Cocientes" href="05-modulos-cocientes.html" />
    <link rel="prev" title="5. Representaciones y representaciones matriciales" href="03-representaciones-y-representaciones-matriciales.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Teoría de Representaciones de Grupos
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Buscar documentos" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contenidos:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="01-grupos.html">1. Grupos</a></li>
<li class="toctree-l1"><a class="reference internal" href="01-ejemplo-de-accion-de-un-grupo-sobre-un-conjunto.html">2. Ejemplos de acción de un grupo sobre un conjunto</a></li>
<li class="toctree-l1"><a class="reference internal" href="01-representaciones-por-permutacion-y-acciones.html">3. Representaciones por Permutacion y Acciones</a></li>
<li class="toctree-l1"><a class="reference internal" href="02-representaciones-acciones-lineales-y-modulos.html">4. Representaciones, Acciones lineales y módulos</a></li>
<li class="toctree-l1"><a class="reference internal" href="03-representaciones-y-representaciones-matriciales.html">5. Representaciones y representaciones matriciales</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">6. Matrices Interventoras</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#estabilizador">6.1. Estabilizador</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#definicion-de-estabilizador">6.1.1. Definición de Estabilizador</a></li>
<li class="toctree-l3"><a class="reference internal" href="#definicion-de-orbita">6.1.2. Definición de Órbita</a></li>
<li class="toctree-l3"><a class="reference internal" href="#las-orbitas-de-un-grupo-sobre-un-conjunto-como-clases-de-equivalencia">6.1.3. Las órbitas de un Grupo sobre un Conjunto como clases de equivalencia</a></li>
<li class="toctree-l3"><a class="reference internal" href="#realcion-entre-el-estabilizador-y-la-orbita-de-un-elemento">6.1.4. Realción entre el estabilizador y la órbita de un elemento</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id1">6.2. Matrices Interventoras</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#definicion">6.2.1. Definición</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#implementacion-en-gap">6.3. Implementacion en GAP</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#groupsumbsgs">6.3.1. GroupSumBSGS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#isomorfismos-entre-representaciones-lineales">6.3.2. Isomorfismos entre Representaciones Lineales</a></li>
<li class="toctree-l3"><a class="reference internal" href="#linearrepresentationisomorphismslow">6.3.3. LinearRepresentationIsomorphismSlow</a></li>
<li class="toctree-l3"><a class="reference internal" href="#arerepsisomorphic">6.3.4. AreRepsIsomorphic</a></li>
<li class="toctree-l3"><a class="reference internal" href="#islinearrepresentationisomorphism">6.3.5. IsLinearRepresentationIsomorphism</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="05-modulos-cocientes.html">7. Módulos Cocientes</a></li>
<li class="toctree-l1"><a class="reference internal" href="06-modulos-indescomponibles-y-modulos-irreducibles.html">8. Módulos Indescomponibles y Módulos Irreducibles</a></li>
<li class="toctree-l1"><a class="reference internal" href="07-relaciones-de-ortogonalidad.html">9. Relaciones de ortogonalidad</a></li>
<li class="toctree-l1"><a class="reference internal" href="08-la-representacion-regular.html">10. La Representación Regular</a></li>
<li class="toctree-l1"><a class="reference internal" href="09-el-espacio-coordenado-de-una-representacion.html">11. El Espacio Coordinado de una Representación</a></li>
<li class="toctree-l1"><a class="reference internal" href="10-funciones-de-clase.html">12. Funciones de clase</a></li>
<li class="toctree-l1"><a class="reference internal" href="11-funcion-caracteristica.html">13. Función Característica</a></li>
<li class="toctree-l1"><a class="reference internal" href="12-caracterizacion-de-caracteristicas-de-representaciones-complejas-irreducibles-de-un-grupo-finito.html">14. Caracterización de Características de Representaciones Complejas Irreducibles de un Grupo Finito</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Teoría de Representaciones de Grupos</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">6. </span>Matrices Interventoras</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/Notas/04-matrices-interventoras.rst.txt" rel="nofollow"> Ver código fuente de la página</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="matrices-interventoras">
<h1><span class="section-number">6. </span>Matrices Interventoras<a class="headerlink" href="#matrices-interventoras" title="Enlazar permanentemente con este título">¶</a></h1>
<div class="section" id="estabilizador">
<h2><span class="section-number">6.1. </span>Estabilizador<a class="headerlink" href="#estabilizador" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Supongamos que un grupo <span class="math notranslate nohighlight">\(G\)</span> tiene una acción sobre un conjunto <span class="math notranslate nohighlight">\(S\)</span>. Para variar, asumiremos que esta es una acción a derecha, pero declaraciones totalmente análogas también son válidas para acciones izquierdas.</p>
<div class="section" id="definicion-de-estabilizador">
<h3><span class="section-number">6.1.1. </span>Definición de Estabilizador<a class="headerlink" href="#definicion-de-estabilizador" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para cada <span class="math notranslate nohighlight">\(s\in G\)</span> el subconjunto de <span class="math notranslate nohighlight">\(G\)</span></p>
<div class="math notranslate nohighlight">
\[Stab_{G}(s) = \{ g \in G | sg = s \}\]</div>
<p>se llama estabilizador de <span class="math notranslate nohighlight">\(s\)</span> en <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>Es fácil ver que</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(1 \in Stab_{G} (s)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(g^{−1} \in Stab_{G} (s)\)</span> siempre que <span class="math notranslate nohighlight">\(g \in Stab_{G} (s)\)</span> y</p></li>
<li><p><span class="math notranslate nohighlight">\(gh \in Stab_{G} (s)\)</span> siempre que <span class="math notranslate nohighlight">\(g, h \in Stab_{G} (s)\)</span>.</p></li>
</ul>
<p>Por tanto, el estabilizador de <span class="math notranslate nohighlight">\(S\)</span> es un subgrupo de <span class="math notranslate nohighlight">\(G\)</span>.</p>
</div>
<div class="section" id="definicion-de-orbita">
<h3><span class="section-number">6.1.2. </span>Definición de Órbita<a class="headerlink" href="#definicion-de-orbita" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El subconjunto de <span class="math notranslate nohighlight">\(S\)</span> dado por <span class="math notranslate nohighlight">\(\mathcal{O} = \{ sg | g \in G \}\)</span> se llama la órbita de <span class="math notranslate nohighlight">\(s\)</span> bajo la acción de <span class="math notranslate nohighlight">\(G\)</span>.</p>
<ul class="simple">
<li><p>Si <span class="math notranslate nohighlight">\(\mathcal{O} = S\)</span>, entonces se dice que la acción de <span class="math notranslate nohighlight">\(G\)</span> sobre <span class="math notranslate nohighlight">\(S\)</span> es transitiva.</p></li>
</ul>
</div>
<div class="section" id="las-orbitas-de-un-grupo-sobre-un-conjunto-como-clases-de-equivalencia">
<h3><span class="section-number">6.1.3. </span>Las órbitas de un Grupo sobre un Conjunto como clases de equivalencia<a class="headerlink" href="#las-orbitas-de-un-grupo-sobre-un-conjunto-como-clases-de-equivalencia" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Como notación temporal, para <span class="math notranslate nohighlight">\(s, t \in S\)</span> escribamos <span class="math notranslate nohighlight">\(s \sim t\)</span> si existe <span class="math notranslate nohighlight">\(g\in G\)</span> tal que <span class="math notranslate nohighlight">\(sg = t\)</span>.</p>
<ul class="simple">
<li><p>Como <span class="math notranslate nohighlight">\(s1 = s\)</span> tenemos que <span class="math notranslate nohighlight">\(s \sim s\)</span>, para todo <span class="math notranslate nohighlight">\(s \in S\)</span>; entonces la relación <span class="math notranslate nohighlight">\(\sim\)</span> es reflexiva.</p></li>
<li><p>Si <span class="math notranslate nohighlight">\(sg = t\)</span> entonces <span class="math notranslate nohighlight">\(tg^{−1} = s\)</span>; por tanto, si <span class="math notranslate nohighlight">\(s \sim t\)</span> entonces <span class="math notranslate nohighlight">\(t \sim s\)</span>, y entonces <span class="math notranslate nohighlight">\(\sim\)</span> es simétrico.</p></li>
<li><p>Y <span class="math notranslate nohighlight">\(\sim\)</span> también es transitiva, ya que si <span class="math notranslate nohighlight">\(s, t, u \in S\)</span> con <span class="math notranslate nohighlight">\(s \sim t\)</span> y <span class="math notranslate nohighlight">\(t \sim u\)</span> entonces existen <span class="math notranslate nohighlight">\(g, h \in G\)</span> con <span class="math notranslate nohighlight">\(sg = t\)</span> y <span class="math notranslate nohighlight">\(th = u\)</span>, y esto da <span class="math notranslate nohighlight">\(s \sim u\)</span> ya que <span class="math notranslate nohighlight">\(s (gh ) = (sg) h = th = u\)</span>.</p></li>
</ul>
<p>Por tanto, <span class="math notranslate nohighlight">\(\sim\)</span> es una relación de equivalencia y, en consecuencia, el conjunto <span class="math notranslate nohighlight">\(S\)</span> es la unión disjunta de clases de equivalencia <span class="math notranslate nohighlight">\(\sim\)</span>. La clase de equivalencia que contiene <span class="math notranslate nohighlight">\(s\)</span> es el conjunto <span class="math notranslate nohighlight">\(\{t \in S | s \sim t\} = \{sg | g \in G\}\)</span>, que es precisamente la órbita de <span class="math notranslate nohighlight">\(s\)</span>. Las órbitas de <span class="math notranslate nohighlight">\(G\)</span> sobre <span class="math notranslate nohighlight">\(S\)</span> son las clases de equivalencia para la relación <span class="math notranslate nohighlight">\(\sim\)</span> como se definió anteriormente.</p>
</div>
<div class="section" id="realcion-entre-el-estabilizador-y-la-orbita-de-un-elemento">
<h3><span class="section-number">6.1.4. </span>Realción entre el estabilizador y la órbita de un elemento<a class="headerlink" href="#realcion-entre-el-estabilizador-y-la-orbita-de-un-elemento" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Se puede ver que si el estabilizador de un elemento <span class="math notranslate nohighlight">\(s\)</span> es grande, entonces la órbita de <span class="math notranslate nohighlight">\(s\)</span> es pequeña y viceversa. Los dos casos extremos son los siguientes:</p>
<ol class="arabic simple">
<li><p>Si el estabilizador de <span class="math notranslate nohighlight">\(s\)</span> es todo el grupo <span class="math notranslate nohighlight">\(G\)</span>, entonces la órbita es el conjunto singleton <span class="math notranslate nohighlight">\(\{s\}\)</span>. Es decir que, si <span class="math notranslate nohighlight">\(Stab_{G}(s) = \{ g \in G | sg = s \} = G\)</span> entonces la órbita de <span class="math notranslate nohighlight">\(s\)</span> está dada por <span class="math notranslate nohighlight">\(\mathcal{O} = \{ sg | g \in G \} = \{ s | g \in G \} = \{ s \}\)</span>.</p></li>
<li><p>Si el estabilizador es el subgrupo trivial que consiste solo en el elemento de identidad, entonces los elementos de la órbita de <span class="math notranslate nohighlight">\(s\)</span> están en correspondencia uno a uno con los elementos de <span class="math notranslate nohighlight">\(G\)</span> (ya que si <span class="math notranslate nohighlight">\(g, h \in G\)</span> y <span class="math notranslate nohighlight">\(sg = sh\)</span> entonces <span class="math notranslate nohighlight">\(s (gh^{−1}) = s\)</span>, lo que significa que <span class="math notranslate nohighlight">\(gh^{−1} \in Stab_{G} (s) = \{1\}\)</span>, y por lo tanto <span class="math notranslate nohighlight">\(g = h\)</span>).</p></li>
</ol>
<div class="admonition important">
<p class="admonition-title">Importante</p>
<p>En el caso general, si escribimos <span class="math notranslate nohighlight">\(L = Stab_{G} (s)\)</span> entonces <span class="math notranslate nohighlight">\(sg = sh\)</span> si y solo si <span class="math notranslate nohighlight">\(gh^{−1} \in L\)</span>, que es equivalente a <span class="math notranslate nohighlight">\(g \in Lh\)</span>, y esto a su vez es equivalente a la igualdad de las clases laterales derechas <span class="math notranslate nohighlight">\(Lg\)</span> y <span class="math notranslate nohighlight">\(Lh\)</span>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Veamos que si hubiéramos comenzado con una acción izquierda, habríamos obtenido clases laterales izquierdas en este punto: <span class="math notranslate nohighlight">\(gs = hs\)</span> si y solo si <span class="math notranslate nohighlight">\(gL = hL\)</span>.</p>
</div>
<p>Entonces concluimos que hay un mapeo biyectivo bien definido <span class="math notranslate nohighlight">\(sg \mapsto Lg\)</span> desde la órbita <span class="math notranslate nohighlight">\(\mathcal{O} = \{sg | g \in G\}\)</span> al conjunto <span class="math notranslate nohighlight">\(\{ Lg | g \in G \}\)</span> (cuyos elementos son las clases laterales derechas en <span class="math notranslate nohighlight">\(G\)</span> del estabilizador de <span class="math notranslate nohighlight">\(s\)</span>). Por tanto, si <span class="math notranslate nohighlight">\(g_{1}\)</span>, <span class="math notranslate nohighlight">\(g_{2}\)</span>, <span class="math notranslate nohighlight">\(\dots\)</span> , <span class="math notranslate nohighlight">\(g_{m}\)</span> es una transversal derecha para <span class="math notranslate nohighlight">\(L\)</span>, de modo que</p>
<div class="math notranslate nohighlight">
\[G = Lg_{1} \dot{\cup} Lg_{2} \dot{\cup} \cdots \dot{\cup} Lg_{m}\]</div>
<p>(donde «<span class="math notranslate nohighlight">\(\dot{\cup}\)</span>» indica unión disjunta) entonces</p>
<div class="math notranslate nohighlight">
\[\mathcal{O} = \{sg_{1}, sg_{2}, \dots, sg_{m}\},\]</div>
<p>y los <span class="math notranslate nohighlight">\(sg_{i}\)</span> son distintos por pares.</p>
<p>Hay dos formas diferentes de definir las acciones a derecha de un grupo <span class="math notranslate nohighlight">\(G\)</span> sobre el propio <span class="math notranslate nohighlight">\(G\)</span>. En primer lugar, la operación de multiplicación del grupo <span class="math notranslate nohighlight">\(G \times G \to G\)</span> se puede interpretar como una función <span class="math notranslate nohighlight">\(S \times G \to S\)</span>, donde el conjunto <span class="math notranslate nohighlight">\(S\)</span> es igual a <span class="math notranslate nohighlight">\(G\)</span>. Los axiomas de grupo implican inmediatamente que esta función satisface las propiedades definitorias de una acción correcta. A esto lo llamaremos la acción de multiplicación a derecha de <span class="math notranslate nohighlight">\(G\)</span> sobre sí mismo. Es una acción transitiva - solo hay una órbita - ya que si <span class="math notranslate nohighlight">\(s, t \in G\)</span> son arbitrarios, entonces el elemento <span class="math notranslate nohighlight">\(g = s^{−1}t\)</span> satisface <span class="math notranslate nohighlight">\(sg = t\)</span>. Además, el estabilizador de cualquier elemento es trivial, ya que <span class="math notranslate nohighlight">\(sg = g\)</span> implica <span class="math notranslate nohighlight">\(g = 1\)</span>. La otra acción estándar de <span class="math notranslate nohighlight">\(G\)</span> sobre sí mismo es la <em>acción de conjugación</em>. Para evitar confusiones con la acción de multiplicación a derecha, usamos una notación exponencial para la acción de conjugación y definimos <span class="math notranslate nohighlight">\(xg = g^{−1}xg\)</span> para todo <span class="math notranslate nohighlight">\(x, g \in G\)</span>. Tenga en cuenta que mientras que la acción de multiplicación a derecha es una acción de <span class="math notranslate nohighlight">\(G\)</span> sobre <span class="math notranslate nohighlight">\(G\)</span> considerada solo como un conjunto, la acción de conjugación es una acción de <span class="math notranslate nohighlight">\(G\)</span> sobre <span class="math notranslate nohighlight">\(G\)</span> considerado como un grupo.</p>
<p>Porque no solo tenemos <span class="math notranslate nohighlight">\(x^{1} = 1^{−1}x 1 = x\)</span> y</p>
<div class="math notranslate nohighlight">
\[x^{gh} = (gh)^{−1}x(gh) = h^{−1}(g^{−1}xg)h = (g^{−1}xg)^{h} = (x^{g})^{h},\]</div>
<p>para todo <span class="math notranslate nohighlight">\(x, g, h \in G\)</span>, pero también</p>
<div class="math notranslate nohighlight">
\[(xy)^{g} = g^{−1}(xy)g = (g^{−1}xg)(g^{−1}yg) = x{g}y^{g}\]</div>
<p>para todo <span class="math notranslate nohighlight">\(x, y, g \in G\)</span>. Las órbitas de <span class="math notranslate nohighlight">\(G\)</span> bajo la acción de conjugación de <span class="math notranslate nohighlight">\(G\)</span> son, por supuesto, las clases de conjugación, como se define en la lección 4.</p>
</div>
</div>
<div class="section" id="id1">
<h2><span class="section-number">6.2. </span>Matrices Interventoras<a class="headerlink" href="#id1" title="Enlazar permanentemente con este título">¶</a></h2>
<ul class="simple">
<li><p>Sean <span class="math notranslate nohighlight">\(U\)</span> y <span class="math notranslate nohighlight">\(V\)</span> espacios vectoriales sobre <span class="math notranslate nohighlight">\(\mathbb{C}\)</span> que son módulos para el grupo <span class="math notranslate nohighlight">\(G\)</span></p></li>
<li><p>Sea <span class="math notranslate nohighlight">\(f: U \to V\)</span> un <span class="math notranslate nohighlight">\(G\)</span>-homomorfismo. Es decir, <span class="math notranslate nohighlight">\(f\)</span> es un mapa lineal que satisface <span class="math notranslate nohighlight">\(g(fu) = f(gu)\)</span> para todo <span class="math notranslate nohighlight">\(u \in U\)</span> y <span class="math notranslate nohighlight">\(g \in G\)</span>.</p></li>
<li><p>Sean <span class="math notranslate nohighlight">\(\rho: G \to GL (V)\)</span> y <span class="math notranslate nohighlight">\(\sigma: G \to GL (U)\)</span> las representaciones de <span class="math notranslate nohighlight">\(G\)</span> en <span class="math notranslate nohighlight">\(V\)</span> y en <span class="math notranslate nohighlight">\(U\)</span> respectivamente. Es decir, si <span class="math notranslate nohighlight">\(g \in G\)</span> entonces <span class="math notranslate nohighlight">\(\rho g\)</span> es la transformación lineal de <span class="math notranslate nohighlight">\(V\)</span> dada por <span class="math notranslate nohighlight">\(v \mapsto gv\)</span> para todo <span class="math notranslate nohighlight">\(v \in V\)</span>, y <span class="math notranslate nohighlight">\(\sigma g\)</span> es la transformación lineal de <span class="math notranslate nohighlight">\(U\)</span> dada por <span class="math notranslate nohighlight">\(u \mapsto gu\)</span> para todo <span class="math notranslate nohighlight">\(u \in U\)</span>. Para todo <span class="math notranslate nohighlight">\(u \in U\)</span> tenemos</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
    ((\rho g)f)u &amp;= (\rho g)(fu)     &amp;&amp;&amp;&amp;\text{ por composición }\\
                 &amp;= g(fu)            &amp;&amp;&amp;&amp;\text{ por la acción de }\rho\\
                 &amp;= f(gu)            &amp;&amp;&amp;&amp;\text{ por definición de } f\\
                 &amp;= f((\sigma g)u)   &amp;&amp;&amp;&amp;\text{ por la acción de }\sigma\\
                 &amp;= (f(\sigma g))u,  &amp;&amp;&amp;&amp;\text{ por composición }\\
\end{align}\end{split}\]</div>
<p>y entonces <span class="math notranslate nohighlight">\((\rho g) f = f (\sigma g)\)</span>. Esto es válido para todo <span class="math notranslate nohighlight">\(g \in G\)</span>. Se dice que una función <span class="math notranslate nohighlight">\(f\)</span> que satisface <span class="math notranslate nohighlight">\((\rho g) f = f (\sigma g)\)</span> <em>interviene</em> las representaciones <span class="math notranslate nohighlight">\(\rho\)</span> y <span class="math notranslate nohighlight">\(\sigma\)</span>.</p>
<div class="admonition important">
<p class="admonition-title">Importante</p>
<p>Aquí nuevamente tenemos dos palabras que se usan para describir el mismo concepto: una función <em>interviene</em> es lo mismo que un <span class="math notranslate nohighlight">\(G\)</span>-homomorfismo.</p>
</div>
<p>Suponga que <span class="math notranslate nohighlight">\(u_{1}\)</span>, <span class="math notranslate nohighlight">\(u_{2}\)</span>, <span class="math notranslate nohighlight">\(\dots\)</span>, <span class="math notranslate nohighlight">\(u_{n}\)</span> es una base para <span class="math notranslate nohighlight">\(U\)</span> y <span class="math notranslate nohighlight">\(v_{1}\)</span>, <span class="math notranslate nohighlight">\(v_{2}\)</span>, <span class="math notranslate nohighlight">\(\dots\)</span>, <span class="math notranslate nohighlight">\(v_{m}\)</span> es una base para <span class="math notranslate nohighlight">\(V\)</span>, y sea <span class="math notranslate nohighlight">\(A\)</span> la matriz de <span class="math notranslate nohighlight">\(f\)</span> relativa a estas dos bases. Por tanto, <span class="math notranslate nohighlight">\(A\)</span> es la matriz <span class="math notranslate nohighlight">\(m\times n\)</span> con <span class="math notranslate nohighlight">\((i, j)\)</span>-entrada <span class="math notranslate nohighlight">\(a_{ij}\)</span> que satisface <span class="math notranslate nohighlight">\(fu_{j} = \sum_{i = 1}^{m} a_{ij}v_{i}\)</span>. Para cada <span class="math notranslate nohighlight">\(g \in G\)</span> sea <span class="math notranslate nohighlight">\(Rg \in GL (m, \mathbb{C})\)</span> la matriz relativa a la base <span class="math notranslate nohighlight">\(v_{1}\)</span>, <span class="math notranslate nohighlight">\(v_{2}\)</span>, <span class="math notranslate nohighlight">\(\dots\)</span>, <span class="math notranslate nohighlight">\(v_{m}\)</span> de la transformación <span class="math notranslate nohighlight">\(v \mapsto gv\)</span> del espacio <span class="math notranslate nohighlight">\(V\)</span>, y sea <span class="math notranslate nohighlight">\(Sg \in GL (m, \mathbb{C})\)</span> la matriz relativa a la base <span class="math notranslate nohighlight">\(u_{1}\)</span>, <span class="math notranslate nohighlight">\(u_{2}\)</span>, <span class="math notranslate nohighlight">\(\dots\)</span>, <span class="math notranslate nohighlight">\(u_{m}\)</span> de la transformación <span class="math notranslate nohighlight">\(u \mapsto gu\)</span> del espacio <span class="math notranslate nohighlight">\(U\)</span>. Entonces, <span class="math notranslate nohighlight">\(R\)</span> y <span class="math notranslate nohighlight">\(S\)</span> son versiones matriciales de las representaciones <span class="math notranslate nohighlight">\(\rho\)</span> y <span class="math notranslate nohighlight">\(\sigma\)</span>. Y la versión matricial de la ecuación <span class="math notranslate nohighlight">\((\rho g)f = f(\sigma g)\)</span> es <span class="math notranslate nohighlight">\((Rg)A = A(Sg).\)</span></p>
<div class="section" id="definicion">
<h3><span class="section-number">6.2.1. </span>Definición<a class="headerlink" href="#definicion" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Si <span class="math notranslate nohighlight">\(R\)</span> y <span class="math notranslate nohighlight">\(S\)</span> son representaciones matriciales del grupo <span class="math notranslate nohighlight">\(G\)</span> de grados <span class="math notranslate nohighlight">\(m\)</span> y <span class="math notranslate nohighlight">\(n\)</span> respectivamente, se dice que una matriz <span class="math notranslate nohighlight">\(A\)</span> de <span class="math notranslate nohighlight">\(m × n\)</span> interviene <span class="math notranslate nohighlight">\(R\)</span> y <span class="math notranslate nohighlight">\(S\)</span> si <span class="math notranslate nohighlight">\((Rg) A = A (Sg)\)</span> para todo <span class="math notranslate nohighlight">\(g \in G\)</span>.</p>
<p>Entonces, una <strong>matriz interventora</strong> es la versión matricial de un <span class="math notranslate nohighlight">\(G\)</span>-homomorfismo.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<ul class="simple">
<li><p>Un mapa lineal es invertible si y solo si su matriz (relativa a cualquier base) es invertible.</p></li>
<li><p>Es claro que, una matriz <span class="math notranslate nohighlight">\(A\)</span> solo puede ser invertible si es cuadrada, y esto corresponde al hecho que un mapa <span class="math notranslate nohighlight">\(U \to V\)</span> solo puede ser invertible si <span class="math notranslate nohighlight">\(U\)</span> y <span class="math notranslate nohighlight">\(V\)</span> tienen la misma dimensión.</p></li>
</ul>
</div>
<div class="admonition important">
<p class="admonition-title">Importante</p>
<ul class="simple">
<li><p>Un <span class="math notranslate nohighlight">\(G\)</span>-homomorfismo <span class="math notranslate nohighlight">\(f: U \to V\)</span> se llama <span class="math notranslate nohighlight">\(G\)</span>-isomorfismo si es invertible. La versión matricial de esto es una matriz entrelazada que es invertible.</p></li>
</ul>
</div>
<p>Ahora, si <span class="math notranslate nohighlight">\(A\)</span> es invertible, entonces la ecuación <span class="math notranslate nohighlight">\((Rg) A = A (Sg)\)</span> se puede reescribir como <span class="math notranslate nohighlight">\(Rg = A (Sg) A^{− 1}\)</span>, esto significa que las representaciones <span class="math notranslate nohighlight">\(R\)</span> y <span class="math notranslate nohighlight">\(S\)</span> son equivalentes, por <a class="reference internal" href="03-representaciones-y-representaciones-matriciales.html#representaciones-matriciales-equivalente"><span class="std std-ref">Definición</span></a> (Ver Sección <a class="reference internal" href="03-representaciones-y-representaciones-matriciales.html"><span class="doc">Representaciones y representaciones matriciales</span></a>).</p>
<p>Recíprocamente, si <span class="math notranslate nohighlight">\(R\)</span> y <span class="math notranslate nohighlight">\(S\)</span> son equivalentes, de modo que existe una matriz <span class="math notranslate nohighlight">\(A\)</span> interventora invertible, entonces el mapa lineal <span class="math notranslate nohighlight">\(f: U \to V\)</span> cuya matriz relativa a nuestras dos bases fijas es <span class="math notranslate nohighlight">\(A\)</span> es un <span class="math notranslate nohighlight">\(G\)</span>-isomorfismo.</p>
<div class="admonition important">
<p class="admonition-title">Importante</p>
<ul class="simple">
<li><p>Dos <span class="math notranslate nohighlight">\(G\)</span>-módulos son <span class="math notranslate nohighlight">\(G\)</span>-isomorfos si y solo si las representaciones matriciales correspondientes (relativas a cualquier base) son equivalentes.</p></li>
</ul>
</div>
</div>
</div>
<div class="section" id="implementacion-en-gap">
<h2><span class="section-number">6.3. </span>Implementacion en GAP<a class="headerlink" href="#implementacion-en-gap" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="section" id="groupsumbsgs">
<span id="id2"></span><h3><span class="section-number">6.3.1. </span>GroupSumBSGS<a class="headerlink" href="#groupsumbsgs" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <code class="docutils literal notranslate"><span class="pre">GroupSumBSGS(G,</span> <span class="pre">summand)</span></code> devuelve <span class="math notranslate nohighlight">\(\displaystyle\sum_{g \in G} \text{summand}(g)\)</span></p>
<p>Utiliza una cadena estabilizadora básica por <span class="math notranslate nohighlight">\(G\)</span> para calcular la suma descrita anteriormente. Este truco requiere que <code class="docutils literal notranslate"><span class="pre">summand</span></code> sea una función (en el sentido de <strong>GAP</strong>) que defina un homomorfismo monoide (en el sentido matemático). El cálculo de la cadena estabilizadora asume que <span class="math notranslate nohighlight">\(G\)</span> es un grupo.</p>
<p>Más precisamente, si tenemos la cadena estabilizadora básica:</p>
<div class="math notranslate nohighlight">
\[\{1\} = G_{1} \leq \ldots \leq G_{n} = G\]</div>
<p>Atravesamos la cadena desde <span class="math notranslate nohighlight">\(G_{1}\)</span> a <span class="math notranslate nohighlight">\(G_{n}\)</span>, usando la suma anterior <span class="math notranslate nohighlight">\(G_{i-1}\)</span> para construir la suma <span class="math notranslate nohighlight">\(G_{i}\)</span>. Hacemos esto usando el hecho de que (escribiendo <span class="math notranslate nohighlight">\(f\)</span> para <code class="docutils literal notranslate"><span class="pre">summand</span></code>)</p>
<div class="math notranslate nohighlight">
\[\sum_{g \in G_i} f(g) = \sum_{r_j} \left(\sum_{h \in G_{i-1}} f(h)\right) f(r_j)\]</div>
<p>donde <span class="math notranslate nohighlight">\(r_j\)</span> son representantes de la clase lateral derecha de <span class="math notranslate nohighlight">\(G_ {i-1}\)</span> en <span class="math notranslate nohighlight">\(G_{i}\)</span>.</p>
<p>La condición de <code class="docutils literal notranslate"><span class="pre">summand</span></code> se cumple si, por ejemplo, es una representación lineal de un grupo <span class="math notranslate nohighlight">\(G\)</span>.</p>
</div>
<div class="section" id="isomorfismos-entre-representaciones-lineales">
<span id="linearrepresentationisomorphism"></span><h3><span class="section-number">6.3.2. </span>Isomorfismos entre Representaciones Lineales<a class="headerlink" href="#isomorfismos-entre-representaciones-lineales" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Los isomorfismos entre Representaciones Lineales se pueden calcular utilizando la función <code class="docutils literal notranslate"><span class="pre">LinearRepresentationIsomorphism(</span> <span class="pre">rho,</span> <span class="pre">sigma[,</span> <span class="pre">rho_cent_basis</span> <span class="pre">,</span> <span class="pre">sigma_</span> <span class="pre">cent_basis]</span> <span class="pre">)</span></code> la cual retorna una matriz <span class="math notranslate nohighlight">\(A\)</span> o <code class="docutils literal notranslate"><span class="pre">fail</span></code></p>
<p>Sean <span class="math notranslate nohighlight">\(\rho: G \to GL (V)\)</span> y <span class="math notranslate nohighlight">\(\sigma: G \to GL (U)\)</span>. Si existe un mapa lineal <span class="math notranslate nohighlight">\(A: V \to U\)</span> tal que <span class="math notranslate nohighlight">\((\sigma g) A = A(\rho g)\)</span> para todo <span class="math notranslate nohighlight">\(g \in G\)</span>, esta función devuelve uno de esos <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p>Es decir, que <span class="math notranslate nohighlight">\(A\)</span> es el isomorfismo o la función que <em>interviene</em> las representaciones <span class="math notranslate nohighlight">\(\rho\)</span> y <span class="math notranslate nohighlight">\(\sigma\)</span>. <span class="underline">Si las representaciones no son isomorfas</span>, se devuelve <code class="docutils literal notranslate"><span class="pre">fail</span></code>.</p>
<p>Hay tres métodos que podemos usar para calcular un isomorfismo de representaciones lineales, puede seleccionar uno pasando opciones a la función.</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">use_kronecker</span></code>: asume que las matrices son lo suficientemente pequeñas como para que sus productos Kronecker puedan caber en la memoria. Utiliza <a class="reference internal" href="#groupsumbsgs"><span class="std std-ref">GroupSumBSGS</span></a> y <code class="docutils literal notranslate"><span class="pre">KroneckerProduct</span></code> para calcular un elemento del subespacio fijo de <span class="math notranslate nohighlight">\(\rho \otimes \sigma^{\ast}\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">use_orbit_sum</span></code>: Encuentra un isomorfismo sumando las órbitas de la acción de <span class="math notranslate nohighlight">\(\rho \otimes \sigma^{\ast}\)</span> en matrices. Tenga en cuenta que las órbitas pueden ser muy grandes, por lo que esto podría ser tan malo como sumar todo el grupo.</p></li>
<li><p>El valor predeterminado, suma sobre todo el grupo para calcular la proyección en el subespacio fijo.</p></li>
</ul>
</div></blockquote>
<div class="literal-block-wrapper docutils container" id="ejemplo-linearrepresentationisomorphism">
<div class="code-block-caption"><span class="caption-text">función LinearRepresentationIsomorphism</span><a class="headerlink" href="#ejemplo-linearrepresentationisomorphism" title="Enlace permanente a este código fuente">¶</a></div>
<div class="highlight-gap notranslate"><div class="highlight"><pre><span></span><span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">LoadPackage</span><span class="p">(</span> <span class="s">&quot;RepnDecomp&quot;</span> <span class="p">)</span><span class="o">;</span>
────────────────────────────────────────────────────────────────────────────────────────
<span class="nv">Loading</span>  <span class="nv">GRAPE</span> <span class="nv">4</span><span class="o">.</span><span class="nv">8</span><span class="o">.</span><span class="nv">2</span> <span class="p">(</span><span class="nv">GRaph</span> <span class="nv">Algorithms</span> <span class="nv">using</span> <span class="nv">PErmutation</span> <span class="nv">groups</span><span class="p">)</span>
<span class="nv">by</span> <span class="nv">Leonard</span> <span class="nv">H</span><span class="o">.</span> <span class="nv">Soicher</span> <span class="p">(</span><span class="nv">http</span>:<span class="o">//</span><span class="nv">www</span><span class="o">.</span><span class="nv">maths</span><span class="o">.</span><span class="nv">qmul</span><span class="o">.</span><span class="nv">ac</span><span class="o">.</span><span class="nv">uk</span><span class="o">/</span>~<span class="nv">lsoicher</span><span class="o">/</span><span class="p">)</span><span class="o">.</span>
<span class="nv">Homepage</span>: <span class="nv">https</span>:<span class="o">//</span><span class="nv">gap</span><span class="o">-</span><span class="nv">packages</span><span class="o">.</span><span class="nv">github</span><span class="o">.</span><span class="nv">io</span><span class="o">/</span><span class="nv">grape</span>
────────────────────────────────────────────────────────────────────────────────────────
────────────────────────────────────────────────────────────────────────────────────────
<span class="nv">Loading</span>  <span class="nv">RepnDecomp</span> <span class="nv">1</span><span class="o">.</span><span class="nv">1</span><span class="o">.</span><span class="nv">0</span> <span class="p">(</span><span class="nv">Decompose</span> <span class="nv">representations</span> <span class="nv">of</span> <span class="nv">finite</span> <span class="nv">groups</span> <span class="nv">into</span> <span class="nv">irreducibles</span><span class="p">)</span>
<span class="nv">by</span> <span class="nv">Kaashif</span> <span class="nv">Hymabaccus</span> <span class="p">(</span><span class="nv">https</span>:<span class="o">//</span><span class="nv">kaashif</span><span class="o">.</span><span class="nv">co</span><span class="o">.</span><span class="nv">uk</span><span class="p">)</span><span class="o">.</span>
<span class="nv">Homepage</span>: <span class="nv">https</span>:<span class="o">//</span><span class="nv">gap</span><span class="o">-</span><span class="nv">packages</span><span class="o">.</span><span class="nv">github</span><span class="o">.</span><span class="nv">io</span><span class="o">/</span><span class="nv">RepnDecomp</span>
────────────────────────────────────────────────────────────────────────────────────────
<span class="no">true</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="c1"># Ejemplo_LinearRepresentationIsomorphism</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">G</span> <span class="o">:=</span> <span class="nv">SymmetricGroup</span><span class="p">(</span><span class="nv">4</span><span class="p">)</span><span class="o">;;</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">irreps</span> <span class="o">:=</span> <span class="nv">IrreducibleRepresentations</span><span class="p">(</span><span class="nv">G</span><span class="p">)</span><span class="o">;;</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="c1"># rho y tau son isomorfos, solo tienen un orden de bloque diferente</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">rho</span> <span class="o">:=</span> <span class="nv">DirectSumOfRepresentations</span><span class="p">([</span><span class="nv">irreps</span><span class="p">[</span><span class="nv">1</span><span class="p">]</span><span class="o">,</span> <span class="nv">irreps</span><span class="p">[</span><span class="nv">3</span><span class="p">]</span><span class="o">,</span> <span class="nv">irreps</span><span class="p">[</span><span class="nv">3</span><span class="p">]])</span><span class="o">;;</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">tau</span> <span class="o">:=</span> <span class="nv">DirectSumOfRepresentations</span><span class="p">([</span><span class="nv">irreps</span><span class="p">[</span><span class="nv">3</span><span class="p">]</span><span class="o">,</span> <span class="nv">irreps</span><span class="p">[</span><span class="nv">1</span><span class="p">]</span><span class="o">,</span> <span class="nv">irreps</span><span class="p">[</span><span class="nv">3</span><span class="p">]])</span><span class="o">;;</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="c1"># tau2 es solo tau con un cambio de base, sigue siendo isomorfo</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">B</span> <span class="o">:=</span> <span class="nv">RandomInvertibleMat</span><span class="p">(</span><span class="nv">5</span><span class="p">)</span><span class="o">;;</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">tau2</span> <span class="o">:=</span> <span class="nv">ComposeHomFunction</span><span class="p">(</span><span class="nv">tau</span><span class="o">,</span> <span class="nv">x</span> <span class="o">-&gt;</span> <span class="nv">B</span><span class="o">^-</span><span class="nv">1</span> <span class="o">*</span> <span class="nv">x</span> <span class="o">*</span> <span class="nv">B</span><span class="p">)</span><span class="o">;;</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="c1"># usando la implementación predeterminada</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">M</span> <span class="o">:=</span> <span class="nv">LinearRepresentationIsomorphism</span><span class="p">(</span><span class="nv">rho</span><span class="o">,</span> <span class="nv">tau</span><span class="p">)</span><span class="o">;;</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">IsLinearRepresentationIsomorphism</span><span class="p">(</span><span class="nv">M</span><span class="o">,</span> <span class="nv">rho</span><span class="o">,</span> <span class="nv">tau</span><span class="p">)</span><span class="o">;</span>
<span class="no">true</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">M</span> <span class="o">:=</span> <span class="nv">LinearRepresentationIsomorphism</span><span class="p">(</span><span class="nv">tau</span><span class="o">,</span> <span class="nv">tau2</span><span class="p">)</span><span class="o">;;</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">IsLinearRepresentationIsomorphism</span><span class="p">(</span><span class="nv">M</span><span class="o">,</span> <span class="nv">tau</span><span class="o">,</span> <span class="nv">tau2</span><span class="p">)</span><span class="o">;</span>
<span class="no">true</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="c1"># usando la implementación de suma de kronecker</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">M</span> <span class="o">:=</span> <span class="nv">LinearRepresentationIsomorphism</span><span class="p">(</span><span class="nv">tau</span><span class="o">,</span> <span class="nv">tau2</span> : <span class="nv">use_kronecker</span><span class="p">)</span><span class="o">;;</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">IsLinearRepresentationIsomorphism</span><span class="p">(</span><span class="nv">M</span><span class="o">,</span> <span class="nv">tau</span><span class="o">,</span> <span class="nv">tau2</span><span class="p">)</span><span class="o">;</span>
<span class="no">true</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="c1"># usando la implementación de suma de órbitas</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">M</span> <span class="o">:=</span> <span class="nv">LinearRepresentationIsomorphism</span><span class="p">(</span><span class="nv">tau</span><span class="o">,</span> <span class="nv">tau2</span> : <span class="nv">use_orbit_sum</span><span class="p">)</span><span class="o">;;</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">IsLinearRepresentationIsomorphism</span><span class="p">(</span><span class="nv">M</span><span class="o">,</span> <span class="nv">tau</span><span class="o">,</span> <span class="nv">tau2</span><span class="p">)</span><span class="o">;</span>
<span class="no">true</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="c1"># dos irreps distintos no son isomorfos</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">M</span> <span class="o">:=</span> <span class="nv">LinearRepresentationIsomorphism</span><span class="p">(</span><span class="nv">irreps</span><span class="p">[</span><span class="nv">1</span><span class="p">]</span><span class="o">,</span> <span class="nv">irreps</span><span class="p">[</span><span class="nv">2</span><span class="p">])</span><span class="o">;</span>
<span class="no">fail</span>
<span class="nv">gap</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="linearrepresentationisomorphismslow">
<span id="id3"></span><h3><span class="section-number">6.3.3. </span>LinearRepresentationIsomorphismSlow<a class="headerlink" href="#linearrepresentationisomorphismslow" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Los isomorfismos entre Representaciones Lineales se pueden calcular de manera más lenta con la función <code class="docutils literal notranslate"><span class="pre">LinearRepresentationIsomorphismSlow(</span> <span class="pre">rho,</span> <span class="pre">tau</span> <span class="pre">)</span></code> que devuelve una matriz <span class="math notranslate nohighlight">\(A\)</span> o <code class="docutils literal notranslate"><span class="pre">fail</span></code></p>
<p>Da el mismo resultado que <a class="reference internal" href="#linearrepresentationisomorphism">LinearRepresentationIsomorphism</a>, pero esta función usa un método más simple que siempre implica sumar sobre <span class="math notranslate nohighlight">\(G\)</span>, sin usar <a class="reference internal" href="#groupsumbsgs"><span class="std std-ref">GroupSumBSGS</span></a>. Esto puede resultar útil en algunos casos si resulta difícil calcular un buen <code class="docutils literal notranslate"><span class="pre">BSGS</span></code>. Sin embargo, para todos los casos que se han probado, es lento (como sugiere el nombre).</p>
<div class="literal-block-wrapper docutils container" id="ejemplo-linearrepresentationisomorphismslow">
<div class="code-block-caption"><span class="caption-text">función LinearRepresentationIsomorphismSlow</span><a class="headerlink" href="#ejemplo-linearrepresentationisomorphismslow" title="Enlace permanente a este código fuente">¶</a></div>
<div class="highlight-gap notranslate"><div class="highlight"><pre><span></span><span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">LoadPackage</span><span class="p">(</span> <span class="s">&quot;RepnDecomp&quot;</span> <span class="p">)</span><span class="o">;</span>
<span class="o">...</span>
<span class="o">...</span> <span class="nv">el</span> <span class="nv">resto</span> <span class="nv">de</span> <span class="nv">código</span> <span class="nv">del</span> <span class="nv">ejemplo</span> <span class="nv">anterior</span>
<span class="o">...</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">M</span> <span class="o">:=</span> <span class="nv">LinearRepresentationIsomorphism</span><span class="p">(</span><span class="nv">irreps</span><span class="p">[</span><span class="nv">1</span><span class="p">]</span><span class="o">,</span> <span class="nv">irreps</span><span class="p">[</span><span class="nv">2</span><span class="p">])</span><span class="o">;</span>
<span class="no">fail</span>
<span class="hll"><span class="nv">gap</span><span class="o">&gt;</span> <span class="c1"># Ejemplo_LinearRepresentationIsomorphismSlow</span>
</span><span class="hll"><span class="nv">gap</span><span class="o">&gt;</span> <span class="c1"># Siguiendo el ejemplo anterior</span>
</span><span class="hll"><span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">M</span> <span class="o">:=</span> <span class="nv">LinearRepresentationIsomorphismSlow</span><span class="p">(</span><span class="nv">rho</span><span class="o">,</span> <span class="nv">tau</span><span class="p">)</span><span class="o">;;</span>
</span><span class="hll"><span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">IsLinearRepresentationIsomorphism</span><span class="p">(</span><span class="nv">M</span><span class="o">,</span> <span class="nv">rho</span><span class="o">,</span> <span class="nv">tau</span><span class="p">)</span><span class="o">;</span>
</span><span class="hll"><span class="no">true</span>
</span><span class="nv">gap</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="arerepsisomorphic">
<span id="id4"></span><h3><span class="section-number">6.3.4. </span>AreRepsIsomorphic<a class="headerlink" href="#arerepsisomorphic" title="Enlazar permanentemente con este título">¶</a></h3>
<p>LPodemos probar isomorfismos entre dos Representaciones Lineales mediante la función <code class="docutils literal notranslate"><span class="pre">AreRepsIsomorphic(</span> <span class="pre">rho,</span> <span class="pre">tau)</span></code>, que devuelve <code class="docutils literal notranslate"><span class="pre">true</span></code> si <code class="docutils literal notranslate"><span class="pre">rho</span></code> y <code class="docutils literal notranslate"><span class="pre">tau</span></code> son isomorfos como representaciones, <code class="docutils literal notranslate"><span class="pre">false</span></code> en caso contrario.</p>
<p>Dado que las representaciones de grupos finitos sobre <span class="math notranslate nohighlight">\(\mathbb{C}\)</span> están determinadas por sus caracteres, es fácil comprobar si dos representaciones son isomorfas comprobando si tienen el mismo carácter. Intentamos utilizar caracteres siempre que sea posible.</p>
<div class="literal-block-wrapper docutils container" id="ejemplo-arerepsisomorphic">
<div class="code-block-caption"><span class="caption-text">función AreRepsIsomorphic</span><a class="headerlink" href="#ejemplo-arerepsisomorphic" title="Enlace permanente a este código fuente">¶</a></div>
<div class="highlight-gap notranslate"><div class="highlight"><pre><span></span><span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">LoadPackage</span><span class="p">(</span> <span class="s">&quot;RepnDecomp&quot;</span> <span class="p">)</span><span class="o">;</span>
<span class="o">...</span>
<span class="o">...</span> <span class="nv">el</span> <span class="nv">resto</span> <span class="nv">de</span> <span class="nv">código</span> <span class="nv">de</span> <span class="nv">los</span> <span class="nv">ejemplos</span> <span class="nv">anteriores</span>
<span class="o">...</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">IsLinearRepresentationIsomorphism</span><span class="p">(</span><span class="nv">M</span><span class="o">,</span> <span class="nv">rho</span><span class="o">,</span> <span class="nv">tau</span><span class="p">)</span><span class="o">;</span>
<span class="no">true</span>
<span class="hll"><span class="nv">gap</span><span class="o">&gt;</span> <span class="c1"># Ejemplo_AreRepsIsomorphic</span>
</span><span class="hll"><span class="nv">gap</span><span class="o">&gt;</span> <span class="c1"># Siguiendo los ejemplos anteriores</span>
</span><span class="hll"><span class="nv">gap</span><span class="o">&gt;</span> <span class="c1"># Algunas representaciones isomorfas</span>
</span><span class="hll"><span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">AreRepsIsomorphic</span><span class="p">(</span><span class="nv">rho</span><span class="o">,</span> <span class="nv">tau</span><span class="p">)</span><span class="o">;</span>
</span><span class="hll"><span class="no">true</span>
</span><span class="hll"><span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">AreRepsIsomorphic</span><span class="p">(</span><span class="nv">rho</span><span class="o">,</span> <span class="nv">tau2</span><span class="p">)</span><span class="o">;</span>
</span><span class="hll"><span class="no">true</span>
</span><span class="hll"><span class="nv">gap</span><span class="o">&gt;</span> <span class="c1"># rho no es iso a irreps[1] ya que rho es irreps[1] más algunas otras cosas</span>
</span><span class="hll"><span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">AreRepsIsomorphic</span><span class="p">(</span><span class="nv">rho</span><span class="o">,</span> <span class="nv">irreps</span><span class="p">[</span><span class="nv">1</span><span class="p">])</span><span class="o">;</span>
</span><span class="hll"><span class="no">false</span>
</span><span class="nv">gap</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="islinearrepresentationisomorphism">
<span id="id5"></span><h3><span class="section-number">6.3.5. </span>IsLinearRepresentationIsomorphism<a class="headerlink" href="#islinearrepresentationisomorphism" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <code class="docutils literal notranslate"><span class="pre">IsLinearRepresentationIsomorphism(</span> <span class="pre">A,</span> <span class="pre">rho,</span> <span class="pre">tau)</span></code> devuelve <code class="docutils literal notranslate"><span class="pre">true</span></code> si <code class="docutils literal notranslate"><span class="pre">rho</span></code> y <code class="docutils literal notranslate"><span class="pre">tau</span></code> son <span class="underline">isomorfos como representaciones con el isomorfismo dado por el mapa lineal</span> <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p>Esta función prueba si, para todo <span class="math notranslate nohighlight">\(g \in G\)</span>, <span class="math notranslate nohighlight">\(A (\rho g) = (\sigma g) A\)</span>. Es decir, se devuelve verdadero si y solo sí <span class="math notranslate nohighlight">\(A\)</span> es el operador entrelazado que lleva <span class="math notranslate nohighlight">\(\rho\)</span> a <span class="math notranslate nohighlight">\(\sigma\)</span>. Veamos,</p>
<div class="literal-block-wrapper docutils container" id="ejemplo-islinearrepresentationisomorphism">
<div class="code-block-caption"><span class="caption-text">función IsLinearRepresentationIsomorphism</span><a class="headerlink" href="#ejemplo-islinearrepresentationisomorphism" title="Enlace permanente a este código fuente">¶</a></div>
<div class="highlight-gap notranslate"><div class="highlight"><pre><span></span><span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">LoadPackage</span><span class="p">(</span> <span class="s">&quot;RepnDecomp&quot;</span> <span class="p">)</span><span class="o">;</span>
<span class="o">...</span>
<span class="o">...</span> <span class="nv">el</span> <span class="nv">resto</span> <span class="nv">de</span> <span class="nv">código</span> <span class="nv">de</span> <span class="nv">los</span> <span class="nv">ejemplos</span> <span class="nv">anteriores</span>
<span class="o">...</span>
<span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">AreRepsIsomorphic</span><span class="p">(</span><span class="nv">rho</span><span class="o">,</span> <span class="nv">irreps</span><span class="p">[</span><span class="nv">1</span><span class="p">])</span><span class="o">;</span>
<span class="no">false</span>
<span class="hll"><span class="nv">gap</span><span class="o">&gt;</span> <span class="c1"># Ejemplo_IsLinearRepresentationIsomorphism</span>
</span><span class="hll"><span class="nv">gap</span><span class="o">&gt;</span> <span class="c1"># Ya hemos visto que esta función se usa mucho en ejemplos anteriores.</span>
</span><span class="hll"><span class="nv">gap</span><span class="o">&gt;</span> <span class="c1"># Si dos representaciones son isomorfas, siempre se cumple lo siguiente:</span>
</span><span class="hll"><span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">IsLinearRepresentationIsomorphism</span><span class="p">(</span><span class="nv">LinearRepresentationIsomorphism</span><span class="p">(</span><span class="nv">rho</span><span class="o">,</span> <span class="nv">tau</span><span class="p">)</span><span class="o">,</span> <span class="nv">rho</span><span class="o">,</span> <span class="nv">tau</span><span class="p">)</span><span class="o">;</span>
</span><span class="hll"><span class="no">true</span>
</span><span class="hll"><span class="nv">gap</span><span class="o">&gt;</span> <span class="c1"># Nota: esta prueba es sensible a las llamados:</span>
</span><span class="hll"><span class="nv">gap</span><span class="o">&gt;</span> <span class="nv">IsLinearRepresentationIsomorphism</span><span class="p">(</span><span class="nv">LinearRepresentationIsomorphism</span><span class="p">(</span><span class="nv">rho</span><span class="o">,</span> <span class="nv">tau</span><span class="p">)</span><span class="o">,</span> <span class="nv">tau</span><span class="o">,</span> <span class="nv">rho</span><span class="p">)</span><span class="o">;</span>
</span><span class="hll"><span class="no">false</span>
</span><span class="nv">gap</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="05-modulos-cocientes.html" class="btn btn-neutral float-right" title="7. Módulos Cocientes" accesskey="n" rel="next">Siguiente <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="03-representaciones-y-representaciones-matriciales.html" class="btn btn-neutral float-left" title="5. Representaciones y representaciones matriciales" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Anterior</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Derechos de autor 2021, Ferreira, Juan David.

    </p>
  </div>
    
    
    
    Construido con <a href="https://www.sphinx-doc.org/">Sphinx</a> usando un
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">tema</a>
    
    proporcionado por <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>